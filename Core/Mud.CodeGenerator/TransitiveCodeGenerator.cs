// -----------------------------------------------------------------------
//  作者：Mud Studio  版权所有 (c) Mud Studio 2025   
//  Mud.CodeGenerator 项目的版权、商标、专利和其他相关权利均受相应法律法规的保护。使用本项目应遵守相关法律法规和许可证的要求。
//  本项目主要遵循 MIT 许可证进行分发和使用。许可证位于源代码树根目录中的 LICENSE-MIT 文件。
//  不得利用本项目从事危害国家安全、扰乱社会秩序、侵犯他人合法权益等法律法规禁止的活动！任何基于本项目开发而产生的一切法律纠纷和责任，我们不承担任何责任！
// -----------------------------------------------------------------------

using Microsoft.CodeAnalysis.Diagnostics;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Text;

namespace Mud.CodeGenerator;

/// <summary>
/// 代码生成器基类。
/// </summary>
public abstract class TransitiveCodeGenerator : IIncrementalGenerator
{
    /// <inheritdoc/>
    public abstract void Initialize(IncrementalGeneratorInitializationContext context);

    /// <summary>
    /// 生成类的后缀名。
    /// </summary>
    protected virtual string ClassSuffix => "";

    private const string LikeQueryAttributeName = "LikeQueryAttribute";

    protected const string CompilerGeneratedAttribute = GeneratedCodeConsts.CompilerGeneratedAttribute;
    protected string GeneratedCodeAttribute => GeneratedCodeConsts.GeneratedCodeAttribute;

    /// <summary>
    /// 原始实体类的后缀名。
    /// </summary>
    protected virtual string EntitySuffix { get; set; } = "Entity";

    /// <summary>
    /// 是否将生成的属性名首字母小写，默认为 true
    /// </summary>
    protected virtual bool PropertyNameLowerCaseFirstLetter { get; set; } = true;

    /// <summary>
    /// 获取生成代码的默认引入的命名空间。
    /// </summary>
    /// <returns></returns>
    protected virtual Collection<string> GetFileUsingNameSpaces()
    {
        return ["System", "System.ComponentModel.DataAnnotations", "System.Runtime.CompilerServices", "System.Linq.Expressions"];
    }

    /// <summary>
    /// 根据注解名获取需要进行代码辅助生成的类。
    /// </summary>
    /// <param name="context"><see cref="IncrementalGeneratorInitializationContext"/>对象。</param>
    /// <param name="attributeNames">需要查找的特性名称数组。</param>
    /// <returns></returns>
    protected IncrementalValueProvider<ImmutableArray<T?>> GetClassDeclarationProvider<T>(IncrementalGeneratorInitializationContext context, string[] attributeNames) where T : TypeDeclarationSyntax
    {
        // 获取所有带有指定特性的类
        var generationInfo = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, c) => node is T,
                transform: (ctx, c) =>
                {
                    var classNode = (T)ctx.Node;
                    var semanticModel = ctx.SemanticModel;
                    var symbol = semanticModel.GetDeclaredSymbol(classNode, cancellationToken: default);

                    if (symbol?.GetAttributes().Any(a => attributeNames.Contains(a.AttributeClass?.Name)) ?? false)
                    {
                        return classNode;
                    }

                    return null;
                })
            .Where(static s => s is not null)
            .Collect();
        return generationInfo;
    }

    /// <summary>
    /// 生成通用的文件头部
    /// </summary>
    public void GenerateFileHeader(StringBuilder sb)
    {
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// 此代码由Mud源生成器自动生成，请勿手动修改");
        sb.AppendLine($"// 生成时间: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");

        var usingNamespaces = GetFileUsingNameSpaces();
        foreach (var usingNamespace in usingNamespaces)
        {
            sb.AppendLine($"using {usingNamespace};");
        }
    }

    /// <summary>
    /// 生成<see cref="CompilationUnitSyntax"/>对象。
    /// </summary>
    /// <param name="localClass">本地类声明。</param>
    /// <param name="localNamespace">本地命名空间。</param>
    /// <param name="localClassName">本地类名。</param>
    /// <returns></returns>
    protected CompilationUnitSyntax GenCompilationUnitSyntax(ClassDeclarationSyntax localClass, string localNamespace, string localClassName)
    {
        var compilationUnit = SyntaxFactory.CompilationUnit();
        var usingNamespaces = GetFileUsingNameSpaces();
        foreach (var usingNamespace in usingNamespaces)
        {
            compilationUnit = compilationUnit.AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName(usingNamespace)));
        }

        compilationUnit = compilationUnit.WithLeadingTrivia(SyntaxFactory.TriviaList([
                                                                   SyntaxFactory.Comment("// <auto-generated/>"),
                                                                   SyntaxFactory.Comment("// 此代码由Mud代码生成器自动生成，请不要手动修改。"),
                                                                   SyntaxFactory.Comment("// 生成时间: " + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss", CultureInfo.CurrentCulture)),
                                                                   SyntaxFactory.Comment(""),
                                                                   SyntaxFactory.Trivia(SyntaxFactory.PragmaWarningDirectiveTrivia(
                                                                                     SyntaxFactory.Token(SyntaxKind.DisableKeyword), true)
                                                                                    .WithTrailingTrivia(SyntaxFactory.CarriageReturnLineFeed)),
                                                                   SyntaxFactory.Trivia(SyntaxFactory.NullableDirectiveTrivia(
                                                                                      SyntaxFactory.Token(SyntaxKind.EnableKeyword), true)
                                                                                      .WithTrailingTrivia(SyntaxFactory.CarriageReturnLineFeed))]))
                         .AddMembers(SyntaxFactory.NamespaceDeclaration(SyntaxFactory.IdentifierName(localNamespace))
                                                   .AddMembers(localClass))
                         .NormalizeWhitespace();
        return compilationUnit;
    }

    /// <summary>
    /// 从项目配置中读取实体后缀名
    /// </summary>
    /// <param name="options">分析器配置选项。</param>
    protected void InitEntityPrefixValue(AnalyzerConfigOptions options)
    {
        ProjectConfigHelper.ReadProjectOptions(options, "build_property.EntitySuffix", val => EntitySuffix = val, "Entity");
        ProjectConfigHelper.ReadProjectOptions(options, "build_property.PropertyNameLowerCaseFirstLetter", val => PropertyNameLowerCaseFirstLetter = bool.Parse(val), "true");
    }



    /// <summary>
    /// 获取项目文件所在路径及项目文件内容。
    /// </summary>
    /// <param name="context"><see cref="IncrementalGeneratorInitializationContext"/>对象。</param>
    /// <returns></returns>
    protected IncrementalValueProvider<ImmutableArray<(string filePath, string fileContent)>> GetProjectFileInfo(IncrementalGeneratorInitializationContext context)
    {
        var additionalTexts = context.AdditionalTextsProvider;
        var projectFileInfo = additionalTexts
                           .Where(static text => text.Path.EndsWith(".csproj", StringComparison.CurrentCultureIgnoreCase))
                           .Select(static (text, cancellationToken) =>
                           {
                               var projectFilePath = text.Path;
                               var projectFileContent = text.GetText(cancellationToken).ToString();
                               return (projectFilePath, projectFileContent);
                           }).Collect();
        return projectFileInfo;
    }


    /// <summary>
    /// 获取XML文档注释
    /// </summary>
    protected string GetXmlDocumentation(SyntaxNode syntaxNode)
    {
        if (syntaxNode == null)
            return string.Empty;

        var leadingTrivia = syntaxNode.GetLeadingTrivia();
        var xmlDocTrivia = leadingTrivia.FirstOrDefault(t => t.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia) ||
                                                             t.IsKind(SyntaxKind.MultiLineDocumentationCommentTrivia));

        if (xmlDocTrivia != default)
        {
            return xmlDocTrivia.ToFullString();
        }

        return string.Empty;
    }

    #region Property Name Handling
    /// <summary>
    /// 获取实体需要生成的属性信息（从配置信息中决定属性名首字母是否大小写）。
    /// </summary>
    /// <typeparam name="T">成员声明类型。</typeparam>
    /// <param name="declarationSyntax">成员声明语法。</param>
    /// <returns>属性名和属性类型元组。</returns>
    protected (string propertyName, string propertyType) GetGeneratorProperty<T>(T declarationSyntax)
        where T : MemberDeclarationSyntax
    {
        if (declarationSyntax == null)
            return ("", "");

        return declarationSyntax switch
        {
            PropertyDeclarationSyntax propertySyntax => GetPropertyInfo(propertySyntax),
            FieldDeclarationSyntax fieldSyntax => GetFieldInfo(fieldSyntax),
            _ => ("", "")
        };
    }

    /// <summary>
    /// 获取实体需要生成的属性信息。
    /// </summary>
    /// <param name="propertySymbol">属性符号。</param>
    /// <returns>属性名和属性类型元组。</returns>
    protected (string propertyName, string propertyType) GetGeneratorProperty(IPropertySymbol propertySymbol)
    {
        if (propertySymbol == null)
            return ("", "");

        var propertyName = ApplyNameCaseConvention(propertySymbol.Name);
        var propertyType = propertySymbol.Type.OriginalDefinition.Name;
        return (propertyName, propertyType);
    }

    /// <summary>
    /// 获取属性信息。
    /// </summary>
    /// <param name="propertySyntax">属性声明语法。</param>
    /// <returns>属性名和属性类型元组。</returns>
    private (string propertyName, string propertyType) GetPropertyInfo(PropertyDeclarationSyntax propertySyntax)
    {
        var propertyName = ApplyNameCaseConvention(GetOrgPropertyName(propertySyntax));
        var propertyType = SyntaxHelper.GetPropertyType(propertySyntax);
        return (propertyName, propertyType);
    }

    /// <summary>
    /// 获取字段信息。
    /// </summary>
    /// <param name="fieldSyntax">字段声明语法。</param>
    /// <returns>属性名和属性类型元组。</returns>
    private (string propertyName, string propertyType) GetFieldInfo(FieldDeclarationSyntax fieldSyntax)
    {
        var fieldName = GetFieldName(fieldSyntax);
        var propertyName = ApplyNameCaseConvention(ToPropertyName(fieldName));
        var propertyType = SyntaxHelper.GetPropertyType(fieldSyntax);
        return (propertyName, propertyType);
    }

    /// <summary>
    /// 根据配置应用命名大小写约定。
    /// </summary>
    /// <param name="name">原始名称。</param>
    /// <returns>应用约定后的名称。</returns>
    protected string ApplyNameCaseConvention(string name)
    {
        return PropertyNameLowerCaseFirstLetter ?
            StringExtensions.ToLowerFirstLetter(name) :
            name;
    }

    /// <summary>
    /// 获取基于字段声明的属性名（基于字段声明）。
    /// </summary>
    /// <param name="declarationSyntax">字段声明。</param>
    protected string GetPropertyName(FieldDeclarationSyntax declarationSyntax)
    {
        var fieldName = GetFieldName(declarationSyntax);
        return ApplyNameCaseConvention(ToPropertyName(fieldName));
    }

    /// <summary>
    /// 获取首字母小写的属性名（根据配置）。
    /// </summary>
    /// <param name="declarationSyntax">属性声明。</param>
    /// <returns>首字母小写的属性名。</returns>
    protected virtual string GetPropertyName(PropertyDeclarationSyntax declarationSyntax)
    {
        return ApplyNameCaseConvention(GetOrgPropertyName(declarationSyntax));
    }

    /// <summary>
    /// 获取原始的属性名。
    /// </summary>
    /// <param name="declarationSyntax">属性声明。</param>
    /// <returns>属性名。</returns>
    protected string GetOrgPropertyName(PropertyDeclarationSyntax declarationSyntax)
    {
        if (declarationSyntax?.Identifier == null)
            return string.Empty;
        return declarationSyntax.Identifier.Text;
    }

    /// <summary>
    /// 获取字段的变量名。
    /// </summary>
    /// <param name="declarationSyntax">字段声明。</param>
    /// <returns>字段变量名。</returns>
    protected string GetFieldName(FieldDeclarationSyntax declarationSyntax) => GetFieldName(declarationSyntax?.Declaration);

    /// <summary>
    /// 获取字段的变量名。
    /// </summary>
    /// <param name="declarationSyntax">变量声明。</param>
    /// <returns>字段变量名。</returns>
    private string GetFieldName(VariableDeclarationSyntax? declarationSyntax)
    {
        if (declarationSyntax == null)
            return "";

        foreach (var variable in declarationSyntax.Variables)
        {
            var identifierToken = variable.Identifier;
            if (identifierToken.IsKind(SyntaxKind.IdentifierToken))
            {
                return identifierToken.Text;
            }
        }
        return null;
    }

    /// <summary>
    /// 将字段名转换为属性名。
    /// </summary>
    /// <param name="fieldName">待转换的字段名。</param>
    /// <returns>属性名。</returns>
    protected string ToPropertyName(string fieldName)
    {
        if (string.IsNullOrEmpty(fieldName))
            return "";

        var propertyName = ExtractPropertyNameFromField(fieldName);
        return StringExtensions.ToUpperFirstLetter(propertyName);
    }

    /// <summary>
    /// 从字段名中提取属性名（处理下划线前缀）。
    /// </summary>
    /// <param name="fieldName">字段名。</param>
    /// <returns>提取的属性名。</returns>
    private static string ExtractPropertyNameFromField(string fieldName)
    {
        var index = fieldName.IndexOf("_", StringComparison.CurrentCultureIgnoreCase);
        if (index >= 0 && index < 2)
        {
            var parts = fieldName.Split(['_'], StringSplitOptions.RemoveEmptyEntries);
            return parts.Length > 1 ? parts[1] : parts[0];
        }
        return fieldName;
    }
    #endregion

    /// <summary>
    /// 是否为模糊查询属性。
    /// </summary>
    /// <typeparam name="T">成员声明类型。</typeparam>
    /// <param name="memberDeclaration">成员声明。</param>
    /// <returns>是否为模糊查询属性。</returns>
    protected bool IsLikeGenerator<T>(T memberDeclaration)
         where T : MemberDeclarationSyntax
    {
        if (memberDeclaration == null)
            return false;

        var attributes = AttributeSyntaxHelper.GetAttributeSyntaxes(memberDeclaration, LikeQueryAttributeName);
        return attributes != null && attributes.Any();
    }

    /// <summary>
    /// 报告生成失败的诊断信息
    /// </summary>
    /// <param name="context">源码生成上下文</param>
    /// <param name="descriptor">诊断描述符</param>
    /// <param name="className">类名</param>
    protected void ReportFailureDiagnostic(
        SourceProductionContext context,
        DiagnosticDescriptor descriptor,
        string className)
    {
        context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, className));
    }

    /// <summary>
    /// 报告生成错误的诊断信息
    /// </summary>
    /// <param name="context">源码生成上下文</param>
    /// <param name="descriptor">诊断描述符</param>
    /// <param name="className">类名</param>
    /// <param name="exception">异常信息</param>
    protected void ReportErrorDiagnostic(
        SourceProductionContext context,
        DiagnosticDescriptor descriptor,
        string className,
        Exception exception)
    {
        context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, className, exception?.Message));
    }

    /// <summary>
    /// 报告警告诊断信息
    /// </summary>
    /// <param name="context">源码生成上下文</param>
    /// <param name="descriptor">诊断描述符</param>
    /// <param name="className">类名</param>
    protected void ReportWarningDiagnostic(
        SourceProductionContext context,
        DiagnosticDescriptor descriptor,
        string className)
    {
        context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, className));
    }

}