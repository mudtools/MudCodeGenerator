using Microsoft.CodeAnalysis.Diagnostics;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Text;

namespace Mud.CodeGenerator;

/// <summary>
/// 代码生成器基类。
/// </summary>
public abstract class TransitiveCodeGenerator : IIncrementalGenerator
{
    /// <inheritdoc/>
    public abstract void Initialize(IncrementalGeneratorInitializationContext context);

    /// <summary>
    /// 生成类的后缀名。
    /// </summary>
    protected virtual string ClassSuffix => "";

    /// <summary>
    /// 识别是否忽略生成特性。
    /// </summary>
    protected const string IgnoreGeneratorAttribute = "IgnoreGeneratorAttribute";
    private const string LikeQueryAttributeName = "LikeQueryAttribute";


    /// <summary>
    /// 原始实体类的后缀名。
    /// </summary>
    protected virtual string EntitySuffix { get; set; } = "Entity";

    /// <summary>
    /// 获取生成代码的默认引入的命名空间。
    /// </summary>
    /// <returns></returns>
    protected virtual Collection<string> GetFileUsingNameSpaces()
    {
        return new Collection<string> { "System", "System.ComponentModel.DataAnnotations", "System.Runtime.CompilerServices", "System.Linq.Expressions" };
    }

    /// <summary>
    /// 根据注解名获取需要进行代码辅助生成的类。
    /// </summary>
    /// <param name="context"><see cref="IncrementalGeneratorInitializationContext"/>对象。</param>
    /// <param name="attributeNames">需要查找的特性名称数组。</param>
    /// <returns></returns>
    protected IncrementalValueProvider<ImmutableArray<ClassDeclarationSyntax?>> GetClassDeclarationProvider(IncrementalGeneratorInitializationContext context, string[] attributeNames)
    {
        // 获取所有带有指定特性的类
        var generationInfo = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is ClassDeclarationSyntax,
                transform: (ctx, _) =>
                {
                    var classNode = (ClassDeclarationSyntax)ctx.Node;
                    var semanticModel = ctx.SemanticModel;
                    var symbol = semanticModel.GetDeclaredSymbol(classNode, cancellationToken: default);

                    if (symbol?.GetAttributes().Any(a => attributeNames.Contains(a.AttributeClass?.Name)) ?? false)
                    {
                        return classNode;
                    }

                    return null;
                })
            .Where(static s => s is not null)
            .Collect();
        return generationInfo;
    }

    /// <summary>
    /// 生成<see cref="CompilationUnitSyntax"/>对象。
    /// </summary>
    /// <param name="localClass">本地类声明。</param>
    /// <param name="localNamespace">本地命名空间。</param>
    /// <param name="localClassName">本地类名。</param>
    /// <returns></returns>
    protected CompilationUnitSyntax GenCompilationUnitSyntax(ClassDeclarationSyntax localClass, string localNamespace, string localClassName)
    {
        var compilationUnit = SyntaxFactory.CompilationUnit();
        var usingNamespaces = GetFileUsingNameSpaces();
        foreach (var usingNamespace in usingNamespaces)
        {
            compilationUnit = compilationUnit.AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName(usingNamespace)));
        }

        compilationUnit = compilationUnit.WithLeadingTrivia(SyntaxFactory.TriviaList([
                                                                   SyntaxFactory.Comment("// <auto-generated/>"),
                                                                   SyntaxFactory.Comment("// 自动生成代码，请不要手动修改。"),
                                                                   SyntaxFactory.Comment("// 生成时间: " + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss", CultureInfo.CurrentCulture)),
                                                                   SyntaxFactory.Comment(""),
                                                                   SyntaxFactory.Trivia(SyntaxFactory.PragmaWarningDirectiveTrivia(
                                                                                     SyntaxFactory.Token(SyntaxKind.DisableKeyword), true)
                                                                                    .WithTrailingTrivia(SyntaxFactory.CarriageReturnLineFeed)),
                                                                   SyntaxFactory.Trivia(SyntaxFactory.NullableDirectiveTrivia(
                                                                                      SyntaxFactory.Token(SyntaxKind.EnableKeyword), true)
                                                                                      .WithTrailingTrivia(SyntaxFactory.CarriageReturnLineFeed))]))
                         .AddMembers(SyntaxFactory.NamespaceDeclaration(SyntaxFactory.IdentifierName(localNamespace))
                                                   .AddMembers(localClass))
                         .NormalizeWhitespace();
        return compilationUnit;
    }

    /// <summary>
    /// 从项目配置中读取实体后缀名
    /// </summary>
    /// <param name="options">分析器配置选项。</param>
    protected void InitEntityPrefixValue(AnalyzerConfigOptions options)
    {
        ReadProjectOptions(options, "build_property.EntitySuffix", val => EntitySuffix = val, "Entity");
    }

    /// <summary>
    /// 从项目配置中读取指定的配置信息。
    /// </summary>
    /// <param name="options">分析器配置选项。</param>
    /// <param name="optionItem">选项键。</param>
    /// <param name="action">处理选项值的操作。</param>
    /// <param name="defaultValue">默认值，当配置中未指定时使用。</param>
    protected void ReadProjectOptions(AnalyzerConfigOptions options, string optionItem, Action<string> action, string defaultValue = null)
    {
        if (options == null)
            return;

        if (options.TryGetValue(optionItem, out var val))
        {
            action?.Invoke(val);
        }
        else if (defaultValue != null)
        {
            action?.Invoke(defaultValue);
        }
    }

    /// <summary>
    /// 获取项目文件所在路径及项目文件内容。
    /// </summary>
    /// <param name="context"><see cref="IncrementalGeneratorInitializationContext"/>对象。</param>
    /// <returns></returns>
    protected IncrementalValueProvider<ImmutableArray<(string filePath, string fileContent)>> GetProjectFileInfo(IncrementalGeneratorInitializationContext context)
    {
        var additionalTexts = context.AdditionalTextsProvider;
        var projectFileInfo = additionalTexts
                           .Where(static text => text.Path.EndsWith(".csproj", StringComparison.CurrentCultureIgnoreCase))
                           .Select(static (text, cancellationToken) =>
                           {
                               var projectFilePath = text.Path;
                               var projectFileContent = text.GetText(cancellationToken).ToString();
                               return (projectFilePath, projectFileContent);
                           }).Collect();
        return projectFileInfo;
    }

    /// <summary>
    /// 根据<see cref="ClassDeclarationSyntax"/>获取当前类所在的命名空间。
    /// </summary>
    /// <param name="classNode">类声明语法节点。</param>
    /// <returns>命名空间名称。</returns>
    protected virtual string GetNamespaceName(ClassDeclarationSyntax classNode)
    {
        if (SyntaxNodeHelper.TryGetParentSyntax(classNode, out NamespaceDeclarationSyntax namespaceDeclarationSyntax))
        {
            return namespaceDeclarationSyntax.Name.ToString();
        }
        else if (SyntaxNodeHelper.TryGetParentSyntax(classNode, out FileScopedNamespaceDeclarationSyntax fileScopedNamespaceDeclaration))
        {
            return fileScopedNamespaceDeclaration.Name.ToString();
        }
        return "";
    }

    /// <summary>
    /// 获取原始的类名。
    /// </summary>
    /// <param name="classNode"><see cref="ClassDeclarationSyntax"/>对象。</param>
    /// <returns>类名。</returns>
    protected string GetClassName(ClassDeclarationSyntax classNode)
    {
        if (classNode == null)
            return "";
        return classNode.Identifier.Text;
    }

    /// <summary>
    /// 获取类声明上的特性对象。
    /// </summary>
    /// <typeparam name="T">需创建的特性类型。</typeparam>
    /// <param name="classDeclaration">类声明<see cref="ClassDeclarationSyntax"/>对象。</param>
    /// <param name="attributeName">注解名。</param>
    /// <param name="paramName">参数名。</param>
    /// <param name="defaultVal">参数默认值。</param>
    /// <returns>返回创建的特性对象。</returns>
    protected T GetClassAttributeValues<T>(ClassDeclarationSyntax classDeclaration, string attributeName, string paramName, T defaultVal)
        where T : notnull
    {
        var attributes = GetAttributeSyntaxes(classDeclaration, attributeName);
        return GetAttributeValue(attributes, paramName, defaultVal);
    }

    /// <summary>
    /// 获取属性声明上的特性对象。
    /// </summary>
    /// <typeparam name="T">需创建的特性类型。</typeparam>
    /// <param name="classDeclaration">类声明<see cref="PropertyDeclarationSyntax"/>对象。</param>
    /// <param name="attributeName">注解名。</param>
    /// <param name="paramName">参数名。</param>
    /// <param name="defaultVal">参数默认值。</param>
    /// <returns>返回创建的特性对象。</returns>
    protected T GetPropertyAttributeValues<T>(PropertyDeclarationSyntax classDeclaration, string attributeName, string paramName, T defaultVal)
       where T : notnull
    {
        if (string.IsNullOrEmpty(attributeName))
            return default;

        var attriShortName = attributeName.Replace("Attribute", "");
        if (classDeclaration == null)
            return defaultVal;

        // 获取类上的特性
        var attributes = GetAttributeSyntaxes(classDeclaration, attriShortName);
        return GetAttributeValue(attributes, paramName, defaultVal);
    }

    /// <summary>
    /// 获取属性上标注的注解。
    /// </summary>
    /// <typeparam name="T">成员声明类型。</typeparam>
    /// <param name="memberDeclaration">成员声明。</param>
    /// <param name="attributeName">特性名称。</param>
    /// <returns>特性语法集合。</returns>
    protected ReadOnlyCollection<AttributeSyntax> GetAttributeSyntaxes<T>(T memberDeclaration, string attributeName)
        where T : MemberDeclarationSyntax
    {
        if (string.IsNullOrEmpty(attributeName))
            return null;

        if (memberDeclaration == null)
            return null;

        var attriShortName = attributeName.Replace("Attribute", "");

        // 获取成员上的特性
        var attributes = memberDeclaration.AttributeLists
                                .SelectMany(al => al.Attributes)
                                .Where(a => a.Name.ToString() == attributeName || a.Name.ToString() == attriShortName)
                                .ToList();
        return new ReadOnlyCollection<AttributeSyntax>(attributes);
    }

    /// <summary>
    /// 获取类上的注解。
    /// </summary>
    /// <param name="classDeclaration">类声明<see cref="ClassDeclarationSyntax"/>对象。</param>
    /// <param name="attributeName">注解名。</param>
    /// <returns>特性语法集合。</returns>
    protected ReadOnlyCollection<AttributeSyntax> GetAttributeSyntaxes(ClassDeclarationSyntax classDeclaration, string attributeName)
    {
        if (string.IsNullOrEmpty(attributeName))
            return new ReadOnlyCollection<AttributeSyntax>([]);

        if (classDeclaration == null)
            return new ReadOnlyCollection<AttributeSyntax>([]);

        var attriShortName = attributeName.Replace("Attribute", "");

        // 获取类上的特性
        var attributes = classDeclaration.AttributeLists
                        .SelectMany(al => al.Attributes)
                        .Where(a => a.Name.ToString() == attributeName || a.Name.ToString() == attriShortName)
                        .ToList();
        return new ReadOnlyCollection<AttributeSyntax>(attributes);
    }

    /// <summary>
    /// 根据<see cref="AttributeSyntax"/>对象获取指定的属性值，必须给定默认值（防止用户未设置）。
    /// </summary>
    /// <typeparam name="T">值类型。</typeparam>
    /// <param name="attributes">特性集合。</param>
    /// <param name="paramName">参数名。</param>
    /// <param name="defaultVal">参数默认值。</param>
    /// <returns>特性参数值。</returns>
    protected T GetAttributeValue<T>(ReadOnlyCollection<AttributeSyntax> attributes, string paramName, T defaultVal)
         where T : notnull
    {
        if (!attributes.Any())
            return defaultVal;

        var attribute = attributes.FirstOrDefault();
        var argumentList = attribute.ArgumentList;
        if (argumentList != null)
        {
            // 检查参数是否存在
            if (!argumentList.Arguments
                  .Any(arg => paramName.Equals(arg.NameEquals?.Name?.Identifier.ValueText, StringComparison.OrdinalIgnoreCase)))
                return defaultVal;

            var paramValue = argumentList.Arguments
                .Where(arg => paramName.Equals(arg.NameEquals?.Name?.Identifier.ValueText, StringComparison.OrdinalIgnoreCase))
                .Select(arg => ParseAttributeValue(arg.Expression))
                .FirstOrDefault();

            if (paramValue != null && paramValue is T pv)
                return pv;
            return defaultVal;
        }
        return defaultVal;
    }

    /// <summary>
    /// 获取表达式的值。
    /// </summary>
    /// <param name="expression">表达式语法。</param>
    /// <returns>表达式的值。</returns>
    protected object ParseAttributeValue(ExpressionSyntax expression)
    {
        if (expression == null)
            return null;

        var kind = expression.Kind();
        switch (kind)
        {
            case SyntaxKind.StringLiteralExpression:
                return ((LiteralExpressionSyntax)expression).Token.ValueText;
            case SyntaxKind.NumericLiteralExpression:
                return Convert.ChangeType(((LiteralExpressionSyntax)expression).Token.Value, typeof(int));
            case SyntaxKind.InvocationExpression:
                var invocation = (InvocationExpressionSyntax)expression;
                var arguments = invocation.ArgumentList.Arguments.Select(arg => arg.ToString()).ToList();
                return arguments.Any() ? string.Join(",", arguments) : "";
            case SyntaxKind.FalseLiteralExpression:
                return false;
            case SyntaxKind.TrueLiteralExpression:
                return true;
            case SyntaxKind.NullLiteralExpression:
                return null;
            default:
                return null;
        }
    }

    /// <summary>
    /// 获取类的所有成员字段（含私有、保护、公开）。
    /// </summary>
    /// <param name="classDeclaration">类声明。</param>
    /// <returns>字段声明集合。</returns>
    protected ReadOnlyCollection<FieldDeclarationSyntax> GetClassMemberField(ClassDeclarationSyntax classDeclaration)
    {
        if (classDeclaration == null)
            return new ReadOnlyCollection<FieldDeclarationSyntax>(new List<FieldDeclarationSyntax>());

        var fields = classDeclaration.Members
            .OfType<FieldDeclarationSyntax>()
            .Where(f => f.Modifiers.Any(m => m.IsKind(SyntaxKind.PrivateKeyword) ||
                                             m.IsKind(SyntaxKind.ProtectedKeyword) ||
                                             m.IsKind(SyntaxKind.PublicKeyword)))
            .ToList();

        return new ReadOnlyCollection<FieldDeclarationSyntax>(fields);
    }

    #region GetGeneratorProperty

    /// <summary>
    /// 获取实体需要生成的属性信息。
    /// </summary>
    /// <typeparam name="T">成员声明类型。</typeparam>
    /// <param name="declarationSyntax"><seealso cref="PropertyDeclarationSyntax"/>属性声明语法。</param>
    /// <returns>属性名和属性类型元组。</returns>
    protected (string propertyName, string propertyType) GetGeneratorProperty<T>(T declarationSyntax)
        where T : MemberDeclarationSyntax
    {
        if (declarationSyntax == null)
            return ("", "");

        if (declarationSyntax is PropertyDeclarationSyntax propertySyntax)
        {
            var propertyName = GetFirstLowerPropertyName(propertySyntax);
            var propertyType = GetPropertyType(propertySyntax);
            return (propertyName, propertyType);
        }
        else if (declarationSyntax is FieldDeclarationSyntax fieldSyntax)
        {
            var propertyName = GetFirstUpperPropertyName(fieldSyntax);
            var propertyType = GetPropertyType(fieldSyntax);
            return (propertyName, propertyType);
        }
        return ("", "");
    }

    /// <summary>
    /// 获取实体需要生成的属性信息。
    /// </summary>
    /// <param name="propertySymbol"><seealso cref="IPropertySymbol"/>属性声明语法。</param>
    /// <returns>属性名和属性类型元组。</returns>
    protected (string propertyName, string propertyType) GetGeneratorProperty(IPropertySymbol propertySymbol)
    {
        if (propertySymbol == null)
            return ("", "");

        var propertyName = ToLowerFirstLetter(propertySymbol.Name);
        var propertyType = propertySymbol.Type.OriginalDefinition.Name;
        return (propertyName, propertyType);
    }

    /// <summary>
    /// 获取属性类型。
    /// </summary>
    /// <typeparam name="T">成员声明类型。</typeparam>
    /// <param name="declarationSyntax">成员声明。</param>
    /// <returns>属性类型。</returns>
    private string GetPropertyType<T>(T declarationSyntax)
         where T : MemberDeclarationSyntax
    {
        var propertyType = "";
        if (declarationSyntax is PropertyDeclarationSyntax propertySyntax)
        {
            propertyType = propertySyntax.Type.ToString();
        }
        else if (declarationSyntax is FieldDeclarationSyntax fieldSyntax)
        {
            propertyType = fieldSyntax.Declaration.Type.ToString();
        }

        if (!propertyType.EndsWith("?", true, CultureInfo.CurrentCulture))
            return propertyType + "?";
        return propertyType;
    }

    /// <summary>
    /// 获取首字母小写的属性名。
    /// </summary>
    /// <param name="declarationSyntax">属性声明。</param>
    /// <returns>首字母小写的属性名。</returns>
    protected string GetFirstLowerPropertyName(PropertyDeclarationSyntax declarationSyntax)
    {
        return ToLowerFirstLetter(GetPropertyName(declarationSyntax));
    }

    /// <summary>
    /// 获取首字母大写的属性名（基于字段声明）。
    /// </summary>
    /// <param name="declarationSyntax">字段声明。</param>
    /// <returns>首字母大写的属性名。</returns>
    protected string GetFirstUpperPropertyName(FieldDeclarationSyntax declarationSyntax)
    {
        return ToPropertyName(GetFieldName(declarationSyntax));
    }

    /// <summary>
    /// 获取原始的属性名。
    /// </summary>
    /// <param name="declarationSyntax">属性声明。</param>
    /// <returns>属性名。</returns>
    protected string GetPropertyName(PropertyDeclarationSyntax declarationSyntax) => declarationSyntax?.Identifier.Text;

    /// <summary>
    /// 获取字段的变量名。
    /// </summary>
    /// <param name="declarationSyntax">字段声明。</param>
    /// <returns>字段变量名。</returns>
    protected string GetFieldName(FieldDeclarationSyntax declarationSyntax) => GetFieldName(declarationSyntax?.Declaration);

    /// <summary>
    /// 获取字段的变量名。
    /// </summary>
    /// <param name="declarationSyntax">变量声明。</param>
    /// <returns>字段变量名。</returns>
    protected string GetFieldName(VariableDeclarationSyntax? declarationSyntax)
    {
        if (declarationSyntax == null)
            return "";

        foreach (var variable in declarationSyntax.Variables)
        {
            var identifierToken = variable.Identifier;
            if (identifierToken.IsKind(SyntaxKind.IdentifierToken))
            {
                return identifierToken.Text;
            }
        }
        return null;
    }

    /// <summary>
    /// 将首字母小写。
    /// </summary>
    /// <param name="input">输入字符串。</param>
    /// <returns>首字母小写的字符串。</returns>
    protected string ToLowerFirstLetter(string input)
    {
        if (string.IsNullOrEmpty(input) || input.Length <= 2)
        {
            return input?.ToLower(CultureInfo.CurrentCulture) ?? string.Empty;
        }
        return char.ToLower(input[0], CultureInfo.CurrentCulture) + input.Substring(1);
    }

    /// <summary>
    /// 将首字母大写。
    /// </summary>
    /// <param name="input">输入字符串。</param>
    /// <returns>首字母大写的字符串。</returns>
    protected string ToUpperFirstLetter(string input)
    {
        if (string.IsNullOrEmpty(input) || input.Length < 2)
        {
            return input?.ToUpper(CultureInfo.CurrentCulture) ?? string.Empty;
        }
        return char.ToUpper(input[0], CultureInfo.CurrentCulture) + input.Substring(1);
    }

    /// <summary>
    /// 将字段名转换位属性名
    /// </summary>
    /// <param name="fieldName">待转换的字段名</param>
    /// <returns>属性名。</returns>
    protected string ToPropertyName(string fieldName)
    {
        if (string.IsNullOrEmpty(fieldName))
            return "";

        var propertyName = fieldName;
        var index = fieldName.IndexOf("_", StringComparison.CurrentCultureIgnoreCase);
        if (index >= 0 && index < 2)
        {
            var t = fieldName.Split(['_'], StringSplitOptions.RemoveEmptyEntries);
            propertyName = t.Length > 1 ? t[1] : t[0];
        }
        return ToUpperFirstLetter(propertyName);
    }
    #endregion   

    /// <summary>
    /// 获取类型名。
    /// </summary>
    /// <param name="typeSyntax">类型语法。</param>
    /// <returns>类型名称。</returns>
    protected string GetTypeSyntaxName(TypeSyntax typeSyntax)
    {
        if (typeSyntax is IdentifierNameSyntax identifierName)
        {
            return identifierName.Identifier.Text;
        }
        else if (typeSyntax is GenericNameSyntax genericName)
        {
            return genericName.Identifier.Text;
        }
        else if (typeSyntax is QualifiedNameSyntax qualifiedName)
        {
            return $"{GetTypeSyntaxName(qualifiedName.Left)}.{GetTypeSyntaxName(qualifiedName.Right)}";
        }
        else if (typeSyntax is PredefinedTypeSyntax predefinedType)
        {
            return predefinedType.Keyword.Text;
        }
        else if (typeSyntax is ArrayTypeSyntax arrayType)
        {
            return $"{GetTypeSyntaxName(arrayType.ElementType)}[]";
        }
        else if (typeSyntax is PointerTypeSyntax pointerType)
        {
            return $"{GetTypeSyntaxName(pointerType.ElementType)}*";
        }
        else if (typeSyntax is NullableTypeSyntax nullableType)
        {
            return $"{GetTypeSyntaxName(nullableType.ElementType)}?";
        }
        else if (typeSyntax is TupleTypeSyntax tupleType)
        {
            return $"({string.Join(", ", tupleType.Elements.Select(e => GetTypeSyntaxName(e.Type)))})";
        }
        else
        {
            return typeSyntax?.ToString() ?? string.Empty;
        }
    }

    /// <summary>
    /// 是否为模糊查询属性。
    /// </summary>
    /// <typeparam name="T">成员声明类型。</typeparam>
    /// <param name="memberDeclaration">成员声明。</param>
    /// <returns>是否为模糊查询属性。</returns>
    protected bool IsLikeGenerator<T>(T memberDeclaration)
         where T : MemberDeclarationSyntax
    {
        if (memberDeclaration == null)
            return false;

        var attributes = GetAttributeSyntaxes(memberDeclaration, LikeQueryAttributeName);
        return attributes != null && attributes.Any();
    }

    /// <summary>
    /// 将字符串解释为<see cref="MethodDeclarationSyntax"/>对象。
    /// </summary>
    /// <param name="sb">字符串构建器。</param>
    /// <returns>方法声明语法。</returns>
    protected MethodDeclarationSyntax GetMethodDeclarationSyntax(StringBuilder sb)
    {
        if (sb == null)
            return null;

        var str = sb.ToString();
        var tree = CSharpSyntaxTree.ParseText(str);
        var root = tree.GetRoot() as CompilationUnitSyntax;
        var methodDeclaration = root.DescendantNodes().OfType<MethodDeclarationSyntax>().FirstOrDefault();
        return methodDeclaration;
    }
}