using Microsoft.CodeAnalysis.Diagnostics;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.Globalization;

namespace Mud.CodeGenerator;

/// <summary>
/// 代码生成器基类。
/// </summary>
public abstract class TransitiveCodeGenerator : IIncrementalGenerator
{
    /// <inheritdoc/>
    public abstract void Initialize(IncrementalGeneratorInitializationContext context);

    /// <summary>
    /// 生成类的后缀名。
    /// </summary>
    protected virtual string ClassSuffix => "";

    /// <summary>
    /// 识别是否忽略生成特性。
    /// </summary>
    protected const string IgnoreGeneratorAttribute = "IgnoreGeneratorAttribute";
    private const string LikeQueryAttributeName = "LikeQueryAttribute";


    /// <summary>
    /// 原始实体类的后缀名。
    /// </summary>
    protected virtual string EntitySuffix { get; set; } = "Entity";

    /// <summary>
    /// 是否将生成的属性名首字母小写，默认为 true
    /// </summary>
    protected virtual bool PropertyNameLowerCaseFirstLetter { get; set; } = true;

    /// <summary>
    /// 获取生成代码的默认引入的命名空间。
    /// </summary>
    /// <returns></returns>
    protected virtual Collection<string> GetFileUsingNameSpaces()
    {
        return ["System", "System.ComponentModel.DataAnnotations", "System.Runtime.CompilerServices", "System.Linq.Expressions"];
    }

    /// <summary>
    /// 根据注解名获取需要进行代码辅助生成的类。
    /// </summary>
    /// <param name="context"><see cref="IncrementalGeneratorInitializationContext"/>对象。</param>
    /// <param name="attributeNames">需要查找的特性名称数组。</param>
    /// <returns></returns>
    protected IncrementalValueProvider<ImmutableArray<ClassDeclarationSyntax?>> GetClassDeclarationProvider(IncrementalGeneratorInitializationContext context, string[] attributeNames)
    {
        // 获取所有带有指定特性的类
        var generationInfo = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, c) => node is ClassDeclarationSyntax,
                transform: (ctx, c) =>
                {
                    var classNode = (ClassDeclarationSyntax)ctx.Node;
                    var semanticModel = ctx.SemanticModel;
                    var symbol = semanticModel.GetDeclaredSymbol(classNode, cancellationToken: default);

                    if (symbol?.GetAttributes().Any(a => attributeNames.Contains(a.AttributeClass?.Name)) ?? false)
                    {
                        return classNode;
                    }

                    return null;
                })
            .Where(static s => s is not null)
            .Collect();
        return generationInfo;
    }

    /// <summary>
    /// 生成<see cref="CompilationUnitSyntax"/>对象。
    /// </summary>
    /// <param name="localClass">本地类声明。</param>
    /// <param name="localNamespace">本地命名空间。</param>
    /// <param name="localClassName">本地类名。</param>
    /// <returns></returns>
    protected CompilationUnitSyntax GenCompilationUnitSyntax(ClassDeclarationSyntax localClass, string localNamespace, string localClassName)
    {
        var compilationUnit = SyntaxFactory.CompilationUnit();
        var usingNamespaces = GetFileUsingNameSpaces();
        foreach (var usingNamespace in usingNamespaces)
        {
            compilationUnit = compilationUnit.AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName(usingNamespace)));
        }

        compilationUnit = compilationUnit.WithLeadingTrivia(SyntaxFactory.TriviaList([
                                                                   SyntaxFactory.Comment("// <auto-generated/>"),
                                                                   SyntaxFactory.Comment("// 此代码由Mud代码生成器自动生成，请不要手动修改。"),
                                                                   SyntaxFactory.Comment("// 生成时间: " + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss", CultureInfo.CurrentCulture)),
                                                                   SyntaxFactory.Comment(""),
                                                                   SyntaxFactory.Trivia(SyntaxFactory.PragmaWarningDirectiveTrivia(
                                                                                     SyntaxFactory.Token(SyntaxKind.DisableKeyword), true)
                                                                                    .WithTrailingTrivia(SyntaxFactory.CarriageReturnLineFeed)),
                                                                   SyntaxFactory.Trivia(SyntaxFactory.NullableDirectiveTrivia(
                                                                                      SyntaxFactory.Token(SyntaxKind.EnableKeyword), true)
                                                                                      .WithTrailingTrivia(SyntaxFactory.CarriageReturnLineFeed))]))
                         .AddMembers(SyntaxFactory.NamespaceDeclaration(SyntaxFactory.IdentifierName(localNamespace))
                                                   .AddMembers(localClass))
                         .NormalizeWhitespace();
        return compilationUnit;
    }

    /// <summary>
    /// 从项目配置中读取实体后缀名
    /// </summary>
    /// <param name="options">分析器配置选项。</param>
    protected void InitEntityPrefixValue(AnalyzerConfigOptions options)
    {
        ProjectConfigHelper.ReadProjectOptions(options, "build_property.EntitySuffix", val => EntitySuffix = val, "Entity");
        ProjectConfigHelper.ReadProjectOptions(options, "build_property.PropertyNameLowerCaseFirstLetter", val => PropertyNameLowerCaseFirstLetter = bool.Parse(val), "true");
    }



    /// <summary>
    /// 获取项目文件所在路径及项目文件内容。
    /// </summary>
    /// <param name="context"><see cref="IncrementalGeneratorInitializationContext"/>对象。</param>
    /// <returns></returns>
    protected IncrementalValueProvider<ImmutableArray<(string filePath, string fileContent)>> GetProjectFileInfo(IncrementalGeneratorInitializationContext context)
    {
        var additionalTexts = context.AdditionalTextsProvider;
        var projectFileInfo = additionalTexts
                           .Where(static text => text.Path.EndsWith(".csproj", StringComparison.CurrentCultureIgnoreCase))
                           .Select(static (text, cancellationToken) =>
                           {
                               var projectFilePath = text.Path;
                               var projectFileContent = text.GetText(cancellationToken).ToString();
                               return (projectFilePath, projectFileContent);
                           }).Collect();
        return projectFileInfo;
    }

    /// <summary>
    /// 根据<see cref="ClassDeclarationSyntax"/>获取当前类所在的命名空间。
    /// </summary>
    /// <param name="classNode">类声明语法节点。</param>
    /// <returns>命名空间名称。</returns>
    protected virtual string GetNamespaceName(ClassDeclarationSyntax classNode)
    {
        if (SyntaxHelper.TryGetParentSyntax(classNode, out NamespaceDeclarationSyntax namespaceDeclarationSyntax))
        {
            return namespaceDeclarationSyntax.Name.ToString();
        }
        else if (SyntaxHelper.TryGetParentSyntax(classNode, out FileScopedNamespaceDeclarationSyntax fileScopedNamespaceDeclaration))
        {
            return fileScopedNamespaceDeclaration.Name.ToString();
        }
        return "";
    }


    #region GetGeneratorProperty

    /// <summary>
    /// 获取实体需要生成的属性信息。
    /// </summary>
    /// <typeparam name="T">成员声明类型。</typeparam>
    /// <param name="declarationSyntax"><seealso cref="PropertyDeclarationSyntax"/>属性声明语法。</param>
    /// <returns>属性名和属性类型元组。</returns>
    protected (string propertyName, string propertyType) GetGeneratorProperty<T>(T declarationSyntax)
        where T : MemberDeclarationSyntax
    {
        if (declarationSyntax == null)
            return ("", "");

        if (declarationSyntax is PropertyDeclarationSyntax propertySyntax)
        {
            var propertyName = GetPropertyName(propertySyntax);
            // 根据配置决定是否将属性名首字母小写
            if (PropertyNameLowerCaseFirstLetter)
            {
                propertyName = ToLowerFirstLetter(propertyName);
            }
            var propertyType = SyntaxHelper.GetPropertyType(propertySyntax);
            return (propertyName, propertyType);
        }
        else if (declarationSyntax is FieldDeclarationSyntax fieldSyntax)
        {
            var propertyName = GetFirstUpperPropertyName(fieldSyntax);
            // 根据配置决定是否将属性名首字母小写
            if (PropertyNameLowerCaseFirstLetter)
            {
                propertyName = ToLowerFirstLetter(propertyName);
            }
            var propertyType = SyntaxHelper.GetPropertyType(fieldSyntax);
            return (propertyName, propertyType);
        }
        return ("", "");
    }

    /// <summary>
    /// 获取实体需要生成的属性信息。
    /// </summary>
    /// <param name="propertySymbol"><seealso cref="IPropertySymbol"/>属性声明语法。</param>
    /// <returns>属性名和属性类型元组。</returns>
    protected (string propertyName, string propertyType) GetGeneratorProperty(IPropertySymbol propertySymbol)
    {
        if (propertySymbol == null)
            return ("", "");

        var propertyName = propertySymbol.Name;
        // 根据配置决定是否将属性名首字母小写
        if (PropertyNameLowerCaseFirstLetter)
        {
            propertyName = ToLowerFirstLetter(propertyName);
        }
        var propertyType = propertySymbol.Type.OriginalDefinition.Name;
        return (propertyName, propertyType);
    }



    /// <summary>
    /// 获取首字母小写的属性名（根据配置）。
    /// </summary>
    /// <param name="declarationSyntax">属性声明。</param>
    /// <returns>首字母小写的属性名。</returns>
    protected string GetFirstLowerPropertyName(PropertyDeclarationSyntax declarationSyntax)
    {
        var propertyName = GetPropertyName(declarationSyntax);
        return PropertyNameLowerCaseFirstLetter ? ToLowerFirstLetter(propertyName) : propertyName;
    }

    /// <summary>
    /// 获取首字母大写的属性名（基于字段声明）。
    /// </summary>
    /// <param name="declarationSyntax">字段声明。</param>
    /// <returns>首字母大写的字符串。</returns>
    protected string GetFirstUpperPropertyName(FieldDeclarationSyntax declarationSyntax)
    {
        var propertyName = ToPropertyName(GetFieldName(declarationSyntax));
        return PropertyNameLowerCaseFirstLetter ? ToLowerFirstLetter(propertyName) : propertyName;
    }

    /// <summary>
    /// 获取原始的属性名。
    /// </summary>
    /// <param name="declarationSyntax">属性声明。</param>
    /// <returns>属性名。</returns>
    protected string GetPropertyName(PropertyDeclarationSyntax declarationSyntax)
    {
        if (declarationSyntax == null)
            return string.Empty;
        if (declarationSyntax.Identifier == null)
            return string.Empty;
        return declarationSyntax.Identifier.Text;
    }

    /// <summary>
    /// 获取字段的变量名。
    /// </summary>
    /// <param name="declarationSyntax">字段声明。</param>
    /// <returns>字段变量名。</returns>
    protected string GetFieldName(FieldDeclarationSyntax declarationSyntax) => GetFieldName(declarationSyntax?.Declaration);

    /// <summary>
    /// 获取字段的变量名。
    /// </summary>
    /// <param name="declarationSyntax">变量声明。</param>
    /// <returns>字段变量名。</returns>
    public static string GetFieldName(VariableDeclarationSyntax? declarationSyntax)
    {
        if (declarationSyntax == null)
            return "";

        foreach (var variable in declarationSyntax.Variables)
        {
            var identifierToken = variable.Identifier;
            if (identifierToken.IsKind(SyntaxKind.IdentifierToken))
            {
                return identifierToken.Text;
            }
        }
        return null;
    }

    /// <summary>
    /// 将首字母小写（根据配置）。
    /// </summary>
    /// <param name="input">输入字符串。</param>
    /// <returns>首字母小写的字符串。</returns>
    protected string ToLowerFirstLetter(string input)
    {
        // 如果不启用首字母小写，则直接返回原字符串
        if (!PropertyNameLowerCaseFirstLetter)
        {
            return input;
        }
        return StringExtensions.ToLowerFirstLetter(input);
    }

    /// <summary>
    /// 将首字母大写（根据配置）。
    /// </summary>
    /// <param name="input">输入字符串。</param>
    /// <returns>首字母大写的字符串。</returns>
    protected string ToUpperFirstLetter(string input)
    {
        // 如果启用了首字母小写，则将首字母小写
        if (PropertyNameLowerCaseFirstLetter)
        {
            return ToLowerFirstLetter(input);
        }

        return StringExtensions.ToUpperFirstLetter(input);
    }

    /// <summary>
    /// 将字段名转换位属性名
    /// </summary>
    /// <param name="fieldName">待转换的字段名</param>
    /// <returns>属性名。</returns>
    protected string ToPropertyName(string fieldName)
    {
        if (string.IsNullOrEmpty(fieldName))
            return "";

        var propertyName = fieldName;
        var index = fieldName.IndexOf("_", StringComparison.CurrentCultureIgnoreCase);
        if (index >= 0 && index < 2)
        {
            var t = fieldName.Split(['_'], StringSplitOptions.RemoveEmptyEntries);
            propertyName = t.Length > 1 ? t[1] : t[0];
        }
        return ToUpperFirstLetter(propertyName);
    }
    #endregion

    /// <summary>
    /// 是否为模糊查询属性。
    /// </summary>
    /// <typeparam name="T">成员声明类型。</typeparam>
    /// <param name="memberDeclaration">成员声明。</param>
    /// <returns>是否为模糊查询属性。</returns>
    protected bool IsLikeGenerator<T>(T memberDeclaration)
         where T : MemberDeclarationSyntax
    {
        if (memberDeclaration == null)
            return false;

        var attributes = AttributeSyntaxHelper.GetAttributeSyntaxes(memberDeclaration, LikeQueryAttributeName);
        return attributes != null && attributes.Any();
    }

     /// <summary>
    /// 报告生成失败的诊断信息
    /// </summary>
    /// <param name="context">源码生成上下文</param>
    /// <param name="descriptor">诊断描述符</param>
    /// <param name="className">类名</param>
    protected void ReportFailureDiagnostic(
        SourceProductionContext context,
        DiagnosticDescriptor descriptor,
        string className)
    {
        context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, className));
    }

    /// <summary>
    /// 报告生成错误的诊断信息
    /// </summary>
    /// <param name="context">源码生成上下文</param>
    /// <param name="descriptor">诊断描述符</param>
    /// <param name="className">类名</param>
    /// <param name="exception">异常信息</param>
    protected void ReportErrorDiagnostic(
        SourceProductionContext context,
        DiagnosticDescriptor descriptor,
        string className,
        Exception exception)
    {
        context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, className, exception?.Message));
    }
}